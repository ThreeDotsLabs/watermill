sql.Executor

Particular instances may differ in:
- schema
- SQL statements (a consequence of different schema) (actually not quite, []interface{} may be used)
- what values/structs the select is scanned onto (a consequence of different schema)
- table names

Instances have in common:
- database/sql should abstract some details of the actual SQL dialects, but statements may differ
- the logic of how offsets and consumer groups work (could be different, but will be easier if made common)
- the transactional bits (some operations *could* support a choice tx/nontx,
but that increases complexity, because of different handling if the input is already a Tx)

Inputs to constructor:
-> db.Connection or sth similar
-> insertQuery
-> selectQuery
-> insertOffsetQuery
-> a `scanRow` function (?)
-> table names (sensible defaults available)

API:
- Executor should expose the current methods of the Adapter interface:
	InsertMessages(ctx context.Context, topic string, messages ...*message.Message) error
	GetMessage(ctx context.Context, topic string, consumerGroup string) (*message.Message, error)
	MarkAcked(ctx context.Context, msg *message.Message, consumerGroup string) error

Issues:
- hard to invent sensible defaults for the SQL statements; they are highly dependent on schema

- a small change in schema might require a relatively big difference in how Executor is constructed
It's hard to design around this problem, because os database/sql's constraints (ORM would probably be overkill)

- should Executor handle transactions or have them provided from outside?
arguably, transactions are part of Executor's logic, because it needs to ascertain consistent state.

- how to pass the target of scanning to the Executor? Maybe a function like:
`func scanRow(row *sql.Row, topic string, consumerGroup string) (*message.Message, error)`?

- how to define in the contract which parameter in the query will be passed at which place?
again, it's a problem because of database/sql's inelasticity, but could be probably made easier with e.g. sqlx
and named parameters in the query.
However, complexity arises, because the end user will have to become familiar with the placeholders etc.

Ideas:
- jmoiron/sqlx allows for some elasticity, like the use of map[string]interface{} for named queries/inserts and so on.
However, the code becomes somewhat muddy then. Not that with database/sql it's any better.

Newer Ideas:
- ACK may be performed by a separate Acker
- Use []interface{} in insertArgs to enable more elasticity
- Publisher takes a *sql.Tx, Subscriber takes a *sql.DB and manages Txs itself.
